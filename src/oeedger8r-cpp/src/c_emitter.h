// Copyright (c) Open Enclave SDK contributors.
// Licensed under the MIT License.

#ifndef C_EMITTER_H
#define C_EMITTER_H

#include <fstream>

#include "ast.h"
#include "f_emitter.h"
#include "utils.h"
#include "w_emitter.h"

class CEmitter
{
    Edl* edl_;
    bool gen_t_c_;
    std::ofstream file_;
    std::string indent_;

  public:
    typedef CEmitter& R;
    R out()
    {
        return *this;
    }

    template <typename T>
    R operator<<(const T& t)
    {
        file_ << indent_ << t << "\n";
        return out();
    }
    template <typename T>
    R operator<<(const T* t)
    {
        if (t)
            file_ << indent_ << t << "\n";
        return out();
    }

  public:
    CEmitter(Edl* edl) : edl_(edl), gen_t_c_(false), file_(), indent_()
    {
    }

    void emit_t_c(const std::string& dir_with_sep = "")
    {
        gen_t_c_ = true;
        file_.open(dir_with_sep + edl_->name_ + "_t.c");
        autogen_preamble(out());
        out() << "#include \"" + edl_->name_ + "_t.h\""
              << ""
              << "#include <openenclave/edger8r/" +
                     std::string(gen_t_c_ ? "enclave.h>" : "host.h>")
              << ""
              << "OE_EXTERNC_BEGIN"
              << ""
              << "/**** Trusted function IDs ****/";
        trusted_function_ids();
        out() << "/**** ECALL marshalling structs. ****/";
        ecall_marshalling_structs();
        out() << "/**** ECALL functions. ****/"
              << "";
        for (Function* f : edl_->trusted_funcs_)
            emit_forwarder(f);
        out() << "/**** ECALL function table. ****/"
              << "";
        ecalls_table();
        out() << "/**** Untrusted function IDs. ****/";
        untrusted_function_ids();
        out() << "/**** OCALL marshalling structs. ****/";
        ocall_marshalling_structs();
        out() << "/**** OCALL function wrappers. ****/"
              << "";
        for (Function* f : edl_->untrusted_funcs_)
            emit_wrapper(f);
        if (edl_->untrusted_funcs_.empty())
            out() << "/* There were no ocalls. */";
        out() << "OE_EXTERNC_END";
        file_.close();
    }

    void emit_u_c(
        const std::string& dir_with_sep = "",
        const std::string& prefix = "")
    {
        gen_t_c_ = false;
        file_.open(dir_with_sep + edl_->name_ + "_u.c");
        autogen_preamble(out());
        out() << "#include \"" + edl_->name_ + "_u.h\""
              << ""
              << "#include <openenclave/edger8r/host.h>"
              << ""
              << "OE_EXTERNC_BEGIN"
              << ""
              << "/**** Trusted function IDs. ****/";
        trusted_function_ids();
        out() << "/**** Trusted function names. ****/";
        trusted_function_names();
        out() << "/**** ECALL marshalling structs. ****/";
        ecall_marshalling_structs();
        out() << "/**** ECALL function wrappers. ****/"
              << "";
        for (Function* f : edl_->trusted_funcs_)
            emit_wrapper(f, prefix);
        out() << "/**** Untrusted function IDs. ****/";
        untrusted_function_ids();
        out() << "/**** OCALL marshalling structs. ****/";
        ocall_marshalling_structs();
        out() << "/**** OCALL functions. ****/"
              << "";
        for (Function* f : edl_->untrusted_funcs_)
            emit_forwarder(f);
        if (edl_->untrusted_funcs_.empty())
            out() << "/* There were no ocalls. */"
                  << "";
        out() << "/**** OCALL function table. ****/"
              << "";
        ocalls_table();
        out() << create_prototype(edl_->name_) << "{"
              << "    return oe_create_enclave("
              << "               path,"
              << "               type,"
              << "               flags,"
              << "               settings,"
              << "               setting_count,"
              << "               _" + edl_->name_ + "_ocall_function_table,"
              << "               " + to_str(edl_->untrusted_funcs_.size()) + ","
              << "               _" + edl_->name_ + "_ecall_info_table,"
              << "                " + to_str(edl_->trusted_funcs_.size()) + ","
              << "               enclave);"
              << "}"
              << "OE_EXTERNC_END\n";
        file_.close();
    }

    void emit_pop_t_c(const std::string& dir_with_sep = "")
    {
        out() << "// PopSGX autogenerated file - Carlos Bilbao bilbao {at} vt.edu";
        gen_t_c_ = true;
        file_.open(dir_with_sep + edl_->name_ + "_t.c");
        autogen_preamble_pop(out());
        out() << "#include \"" + edl_->name_ + "_t.h\""
              << ""
              << "#include <execinfo.h>"
              << "#include <openenclave/edger8r/" +
                     std::string(gen_t_c_ ? "enclave.h>" : "host.h>")
              << "OE_EXTERNC_BEGIN"
              << ""
              << "/**** Trusted function IDs ****/";
        trusted_function_ids();
        out() << "/**** ECALL marshalling structs. ****/";
        ecall_marshalling_structs();
        out() << "/**** ECALL functions. ****/"
              << "";
        for (Function* f : edl_->trusted_funcs_)
            emit_forwarder(f);
        out() << "/**** ECALL function table. ****/"
              << "";
        ecalls_table();
        out() << "/**** Untrusted function IDs. ****/";
        untrusted_function_ids();
        out() << "/**** OCALL marshalling structs. ****/";
        ocall_marshalling_structs();
        out() << "/**** OCALL function wrappers. ****/"
              << "";
        prepare_is_pop_call();
        for (Function* f : edl_->untrusted_funcs_)
            pop_emit_wrapper(f);
        if (edl_->untrusted_funcs_.empty())
            out() << "/* There were no ocalls. */";
        out() << "OE_EXTERNC_END";
        file_.close();
    }

    void pop_ecalls(Function* f)
    {
        std::string args_t = f->name_ + "_args_t";
        bool has_deep_copy_out_ = has_deep_copy_out(edl_, f);

        out() << ""
            << " /* PopSGX generated. Fulfill enclave request from other side. */"
            << "oe_result_t do_oe_call_enclave_" + f->name_ + "(int func_id)"
            << "{"
            << "    oe_result_t _result = OE_FAILURE;"
            << "    size_t _input_buffer_size = 0;"
            << "    size_t _output_buffer_size = 0;"
            << "    size_t _total_buffer_size = 0;"
            << "    uint8_t* _buffer = NULL;"
            << "    uint8_t* _input_buffer = NULL;"
            << "    uint8_t* _output_buffer = NULL, evidence_buffer;"
            << "    size_t _input_buffer_offset = 0, _output_buffer_offset = 0;"
            << "    size_t _output_bytes_written = 0;"
            << "    const void* opt_params;"
            << "    size_t opt_params_size, num_allocations, max_allocation_size;"
            << "    sgx_report_t* report;"
            << "    size_t report_size, format_settings_size;"
            << "    oe_report_t* parsed_report;"
            << "    uint8_t** report_buffer, format_settings;"
            << "    size_t* report_buffer_size, evidence_size;"
            << "    int flags,pem_key_size,evidence_buffer_size, *m,n, *_retval;"
            << "    oe_host_worker_context_t* host_worker_contexts;"
            << "    uint64_t num_host_workers;char *dbname;char *sql;"
            << "    oe_enclave_worker_context_t* context;"
            << "    uint8_t **data, *pem_key, *evidence, *format_settings_buffer;"
            << "    oe_uuid_t *format_id; int socket_fd;"
            << "    int a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16,a17,a18,a19,a20;"
            << "    unsigned char *input_buf, *output_buf;";
            if (f->name_.find("encrypt") != std::string::npos &&
                f->name_.find("close_encryptor") == std::string::npos) { // File encryptor 
                out() << "    int encrypt = 1; encryption_header_t *header, the_header;"
                      << "    char *password = \"password\";"
                      << "    int password_len = strlen(password);";
            }
            if (f->name_.find("encrypt_block") != std::string::npos) { // File encryptor 
                out() << "    unsigned char plaintext_padding_buf[16];"
                      << "    unsigned char ciphertext_padding_buf[16];"
                      << "    //memset(ciphertext_padding_buf, 0, 16);"
                      << "    memset(plaintext_padding_buf, 0, 16);"
                      << "    if (!user_block)__read_block();"
                      << "    strcpy(plaintext_padding_buf,user_block);"
                      << "    plaintext_padding_buf[strcspn(plaintext_padding_buf,\"\\0\")] = ' ';"
                      << "    /* PADDING */ "
                      << "    memset((void*)(plaintext_padding_buf + 5),11,11);"
                      << "    input_buf = (unsigned char *)plaintext_padding_buf;"
                      << "    output_buf = (unsigned char *)ciphertext_padding_buf;"
                      << "    size_t size = 16; int ret;"
                      << "    static int encrypt_done = 1;"; // Assume 1 block (Future work improve) 
            }
            out() << "    " + args_t + " _args, *_pargs_in = NULL, *_pargs_out = NULL;";
            if (has_deep_copy_out_)
            {
            out() << "    uint8_t* _deepcopy_out_buffer = NULL;"
                  << "    size_t _deepcopy_out_buffer_size = 0;"
                  << "    size_t _deepcopy_out_buffer_offset = 0;";
            }
            out() << " "
            << "    /* Fill marshalling struct. */";
            if (f->name_.find("b64") != std::string::npos){ // b64 encode
                    out() << "    char *src, *res; int len;";
            }
            out() << "    memset(&_args, 0, sizeof(_args));";
            WEmitter(edl_, file_).fill_marshalling_struct(f);
            out() << ""
                  << "    /* Compute input buffer size. Include in and in-out "
             "parameters. */";
            WEmitter(edl_, file_).compute_input_buffer_size(f);
            out() << "    "
            << "    /* Compute output buffer size. Include out and in-out "
             "parameters. */";
            WEmitter(edl_, file_).compute_output_buffer_size(f);
            out()
            << "    "
            << "    /* Allocate marshalling buffer. */"
            << " "
            << "    _total_buffer_size = _input_buffer_size;"
            << "    OE_ADD_SIZE(_total_buffer_size, _output_buffer_size);" 
            << "    _buffer = (uint8_t*)oe_malloc(_total_buffer_size);"
            << "    _input_buffer  = _buffer;"
            << "    _output_buffer = _buffer + _input_buffer_size;"
            << ""
            << "    if (_buffer == NULL)"
            << "    {"
            << "        _result = OE_OUT_OF_MEMORY;"
            << "        goto done;"
            << "    }"
            << "    "
            << "    /* Serialize buffer inputs (in and in-out parameters). */";
            WEmitter(edl_, file_).serialize_buffer_inputs(f);
            out() << "    "
            << "    /* Copy args structure (now filled) to input buffer. */"
            << "    memcpy(_pargs_in, &_args, sizeof(*_pargs_in));"
            << " "
            << "    fprintf(stderr, \"Calling %s()\",_" + edl_->name_ + "_ecall_info_table[func_id].name);";
            if (f->name_.find("encrypt_block") != std::string::npos)
            {
                out() << "    if (encrypt_done){"
                      << "        fprintf(stderr,\" to encrypt...\\n\");"
                      << "        encrypt_done = 0;"
                      << "    }"
                      << "    else {"
                      << "        encrypt = 0;"
                      << "        fprintf(stderr,\" to decrypt...\\n\");"
                      << "    }"
                      << " ";
            }
            else {
                out() << "    fprintf(stderr,\"...\\n\");"
                << "";
            }
            if (f->name_.find("encrypt_block") != std::string::npos) // File encryptor
            {  
                out() << "     oe_call_enclave_function_args_t args;"
                      << "     uint64_t arg_out = 0;"
	                  << "     args.function_id = func_id;"
                      << "     args.input_buffer = _input_buffer;"
                      << "     args.input_buffer_size = _input_buffer_size;"
                      << "     args.output_buffer = _output_buffer;"
                      << "     args.output_buffer_size = _output_buffer_size;"
                      << "     args.output_bytes_written = 0;"
                      << "     args.result = OE_UNEXPECTED;"
                      << "     oe_get_ecall_ids(enclave,_" + edl_->name_ + "_ecall_info_table[func_id].name,"
                      << "              &global_id,&func_id);"
		              << "     if (( _result = oe_ecall(enclave,OE_ECALL_CALL_ENCLAVE_FUNCTION,"
		              << "      (uint64_t)&args,&arg_out)) != OE_OK){"
                      << " "
                      << "        fprintf(stderr,\"Encrypt block enclave call failed.\");" 
                      << ""
                      << "        if (_result == OE_BUFFER_TOO_SMALL){"
                      << "                fprintf(stderr,\" Output buffer parameter is too small!\");"
                      << "        }"
                      << "        else if (_result == OE_INVALID_PARAMETER){"
                      << "                fprintf(stderr,\" One or more input parameters are invalid!\");"
                      << "         }"
                      << ""
                      << "        fprintf(stderr,\"\\n\");"     
                      << "        goto done;"
                      << "      }"
                      << "     _output_bytes_written = args.output_bytes_written;" // client -> args.output_buffer
                      << "     goto done;";
            }
            out() << "    if ((_result = oe_call_enclave_function("
            << "             enclave,"
            << "             &global_id,"
            << "             _" + edl_->name_ + "_ecall_info_table[func_id].name,"
            << "             _input_buffer,"
            << "             _input_buffer_size,"
            << "             _output_buffer,"
            << "             _output_buffer_size,"
            << "             &_output_bytes_written)) != OE_OK){";
            
            if (f->name_.find("b64") != std::string::npos)
            { // They succeed (basic math) , but do not pass on input buffer for the time being
                out() << "     _result = OE_OK;"
                      << "      goto done;"
                      << " ";
            }
            out() << " "
            << "        fprintf(stderr,\"Enclave call failed.\");" 
            << ""
            << "        if (_result == OE_BUFFER_TOO_SMALL){"
            << "                fprintf(stderr,\" Output buffer parameter is too small!\");"
            << "        }"
            << "        else if (_result == OE_INVALID_PARAMETER){"
            << "                fprintf(stderr,\" One or more input parameters are invalid!\");"
            << "         }"
            << ""
            << "        fprintf(stderr,\"\\n\");"     
            << "        goto done;"
            << "    }"
            << ""
            << "    /* Setup output arg struct pointer. */"
            << "    _pargs_out = (" + args_t + "*)_output_buffer;"
            << "    OE_ADD_SIZE(_output_buffer_offset, sizeof(*_pargs_out));"
            << "    "
            << "    /* Check if the call succeeded. */"
            << "    if ((_result = _pargs_out->oe_result) != OE_OK){"
            << "        fprintf(stderr,\"pargs_out->oe_result was not succesful\\n\");"  
            << "        goto done;"
            << "    }"
            << "";
            if (f->name_.find("encrypt_block") != std::string::npos)
            {
                out() << "    /* Currently exactly _output_buffer_size bytes must be written. */"
                << "    if (_output_bytes_written != _output_buffer_size)" // 0 != 16
                << "    {"
                << "        fprintf(stderr,\"Error: _output_bytes_written (%ld) != buffer size (%ld)\\n\","
                << "                _output_bytes_written,_output_buffer_size);" 
                << "        _result = OE_FAILURE;"
                << "        goto done;"
                << "    }";
            }
            out() << ""
            << "    /* Unmarshal return value and out, in-out parameters. */";
        if (f->rtype_->tag_ != Void)
            out() << "    *_retval = _pargs_out->oe_retval;";
        else
            out() << "    /* No return value. */";
        out() << "";
        if (has_deep_copy_out_)
        {
            out()
                << "    _deepcopy_out_buffer = _pargs_out->deepcopy_out_buffer;"
                << "    _deepcopy_out_buffer_size = "
                   "_pargs_out->deepcopy_out_buffer_size;";
        }
        WEmitter(edl_, file_).unmarshal_outputs(f);
        out() << "";
        if (has_deep_copy_out_)
            out() << "    if (_deepcopy_out_buffer_offset != "
                     "_deepcopy_out_buffer_size)"
                  << "    {"
                  << "        _result = OE_FAILURE;"
                  << "        goto done;"
                  << "    }"
                  << "";
        WEmitter(edl_, file_).propagate_errno(f);
        out() << "    _result = OE_OK;"
              << ""
              << "done:"
              << "    if (_buffer)"
              << "        oe_free(_buffer);";
        out() << "";
        if (has_deep_copy_out_)
        {
            out() << "    if (_deepcopy_out_buffer)"
                  << "        oe_free(_deepcopy_out_buffer);"
                  << "";
        }
        out() << "    return _result;"
              << "}"
              << "";
    }

    void emit_pop_u_c(
        const std::string& dir_with_sep = "",
        const std::string& prefix = "")
    {
        gen_t_c_ = false;
        int i = 0;
        file_.open(dir_with_sep + edl_->name_ + "_u.c");
        out() << "// PopSGX autogenerated file - Carlos Bilbao bilbao {at} vt.edu";
        autogen_preamble_pop(out());
        out() << "#include \"" + edl_->name_ + "_u.h\""
            << "#include <signal.h>\n#include <assert.h>\n#include <unistd.h>"
            << "#include \"" + edl_->name_ + "_args.h\""
            << "#include <openenclave/host.h>"
            << "#include <openenclave/edger8r/host.h>" 
	        << ""
            << "#include <execinfo.h>"
            << "OE_EXTERNC_BEGIN"
            << ""
            << "extern int verbose_pop_sgx;"
            << ""
            << "static oe_enclave_t *enclave;"
            << "long int heap_offset;"
            << "static uint64_t global_id = OE_GLOBAL_ECALL_ID_NULL;"
            << ""
            << "/**** Trusted function IDs. ****/";
        trusted_function_ids();
        out() << "/**** Trusted function names. ****/";
        trusted_function_names();
        out() << "/**** ECALL marshalling structs. ****/";
        ecall_marshalling_structs();
        out() << "/**** Trusted function array (PopSGX) ****/";
        pop_trusted_function();
        out() << "/**** ECALL function wrappers. ****/"
              << "";
        prepare_is_pop_call();
        for (Function* f : edl_->trusted_funcs_)
            pop_emit_wrapper(f, prefix); 
        out() << "/**** Untrusted function IDs. ****/";
        untrusted_function_ids();
        out() << "/**** OCALL marshalling structs. ****/";
        ocall_marshalling_structs();
        out() << "/**** OCALL functions. ****/"
              << "";
        for (Function* f : edl_->untrusted_funcs_)
            emit_forwarder(f);
        if (edl_->untrusted_funcs_.empty())
            out() << "/* There were no ocalls. */"
                  << "";
        out() << "/**** OCALL function table. ****/"
              << "";
        ocalls_table();
        out() << pop_create_prototype(edl_->name_) << "{"
            << ""
            << "    return oe_create_enclave("
            << "               path,"
            << "               type,"
            << "               flags,"
            << "               settings,"
            << "               setting_count,"
            << "               _" + edl_->name_ + "_ocall_function_table,"
            << "               " + to_str(edl_->untrusted_funcs_.size()) + ","
            << "               _" + edl_->name_ + "_ecall_info_table,"
            << "                " + to_str(edl_->trusted_funcs_.size()) + ","
            << "               enclave);"
            << "}"
            << ""
            << "void __read_block(void)"
            << "{"
            << "     FILE *block_aux;"
            << ""
            << "     // Let us assume file name test_file"
            << "     if (!(block_aux = fopen(\"test_file\",\"r\"))){"
            << "             fprintf(stderr,\"Failed to open block file\");"
            << "             abort();"
            << "    }"
            << "    user_block = calloc(16,1);"
            << ""
            << "    if (fscanf(block_aux,\"%s\",(unsigned char*)user_block) == EOF) {"
            << "             fprintf(stderr,\"Reading the user block failed\\n\");"
            << "             abort();"
            << "    }\n"
            << "}"
            << ""
            << "void busy_wait_server(FILE *aux){"
            << ""
            << "    int ret;"
            << "    char *name= \""+edl_->name_+"host\";"
            << "    char func[100]; "
            << ""
            << "    /* This is called from the untrusted binary executed"
            << "       on the server side, register the signal handler"
            << "       for the ecalls and then busy wait. */"
            << ""
            << "    fscanf(aux,\"%d\",&pid_server);"
            << "    fclose(aux);"
            << "    if (!(aux = fopen(\"aux_server_popsgx\",\"w+\"))){"
            << "             fprintf(stderr,\"trusted server failed to open file\");"
            << "             abort();"
            << "    }"
            << "    fprintf(aux,\"%d\",getpid());"
            << "    fclose(aux);"
            << "    if (verbose_pop_sgx)"
            << "            fprintf(stderr,\">> Server side child (pid %d) running\\n\",getpid());"
            << "    struct sigaction sigact; "
            << "    memset(&sigact,'\\0',sizeof(sigact));"
            << "    sigact.sa_sigaction = &handle_call_request_server;"   
            << "    sigact.sa_flags = SA_SIGINFO;"
            << ""
            << "    if (sigaction(SIGUSR2,&sigact,NULL) < 0)"
            << "            printf(\"SIGNAL HANDLER wasn't register\\n\");"
            << "    while (1){"
            << "        sleep(1);"
            << "    }"      
            << "}"
            << ""
            << "int get_pos(FILE *file)"
            << "{"
            << "    int func_id;"
            << ""
            << "    if (fscanf(file,\"%d\",&func_id) == EOF){"
            << "             fprintf(stderr,\"Reading the function id failed\\n\");"
            << "             abort();"
            << "    }"
            << "    return func_id;"
            << "}"
            << ""
            <<"oe_result_t pop_create_enclave(FILE *file)"
            << "{"
            << "    char *dummy_path;"
            << "    const char *path = \""+ edl_->name_ + "enc.signed\";"
            << "    oe_enclave_type_t type;"
            << "    uint32_t flags, setting_count;"
            << "    const oe_enclave_setting_t* settings = malloc(60);"
            << "    long int dummy_enclave;"
            << ""
            << "    if (fscanf(file,\"%llu\",(unsigned long long int*)&dummy_path) == EOF) {"
            << "             fprintf(stderr,\"Reading the enclave path failed\\n\");"
            << "             abort();"
            << "    }\n"
            << "    if (fscanf(file,\"%d\",(int*)&type) == EOF){"
            << "             fprintf(stderr,\"Reading the type path failed\\n\");"
            << "             abort();"
            << "    }\n"
            << "    if (fscanf(file,\"%d\",&flags) == EOF){"
            << "             fprintf(stderr,\"Reading the enclave flags failed\\n\");"
            << "             abort();"
            << "    }\n"
            << "    if (fscanf(file,\"%llu\",(unsigned long long*)&settings) == EOF){"
            << "             fprintf(stderr,\"Reading the enclave settings failed\\n\");"
            << "             abort();"
            << "    }\n"
            << "    if (fscanf(file,\"%d\",&setting_count) == EOF){"
            << "             fprintf(stderr,\"Reading the enclave setting count failed\\n\");"
            << "             abort();"
            << "    }\n"
            << "    if (fscanf(file,\"%ld\",&dummy_enclave) == EOF){"
            << "             fprintf(stderr,\"Reading the enclave dummy address failed\\n\");"
            << "             abort();"
            << "    }\n"
            << "    if (fscanf(file,\"%ld\",&heap_offset) == EOF){"
            << "             fprintf(stderr,\"Reading the enclave heap offset failed\\n\");"
            << "             abort();"
            << "    }"
            << ""
            << "    flags = 1; // Other values are most likely an error (Future work tune)"
            << "    type = 1; "
            << ""
            << "    return "+raw_pop_create_prototype(edl_->name_)+"(path,type,flags,settings,setting_count,&enclave);"
            <<  "}"
            << ""
            << "void handle_call_request_server(int sig,siginfo_t *siginfo,void *context)"
            << "{"
            << "      char *func,func_name[50];"
            << "      int argc, pos;"
            << "      static int not_first = 1;"
            << "      FILE *bin_aux;"
            << "      oe_result_t result;"
            << ""
            << "      if (!(bin_aux = fopen(\"aux_server_popsgx\",\"r\"))){"
            << "             fprintf(stderr,\"untrusted bin at server failed to open file\");"
            << "             abort();"
            << "      }"
            << ""
            << "      fscanf(bin_aux,\"%s\",func_name);"
            << "      func = malloc(strlen(func_name)+14);"      
            << "      sprintf(func,\"__aux_pop_%s\",func_name);"
            << "      fscanf(bin_aux,\"%d\",&argc);"
            << ""
            << "      if (!strcmp(func,\""+raw_pop_create_prototype(edl_->name_)+ "\")){"
            << "            enclave = NULL;"
            << "            assert(argc == 6);"
            << "            if (verbose_pop_sgx)"
            << "                fprintf(stderr, \"Creating enclave...\\n\");"
            << "            result = pop_create_enclave(bin_aux);"
            << "            if (verbose_pop_sgx)"
            << "                fprintf(stderr, \"Enclave creation result %d\\n\",result);"
            << "            if (result == OE_BUFFER_TOO_SMALL){"
            << "                fprintf(stderr,\" - failure probably due to incorrect path for signed enclave\\n\");"
            << "            }"
            << "            if (result == OE_BUFFER_TOO_SMALL){"
            << "                fprintf(stderr,\" - which means buffer too small\\n\");"
            << "            }"
            << "            if (result == OE_INVALID_PARAMETER){"
            << "                fprintf(stderr,\" - which means invalid parameter\\n\");"
            << "            }"
            << "      } "
            << "      else if (!strcmp(func,\"__aux_pop_oe_terminate_enclave\")){"
            << " "
            << "            fprintf(stderr,\"Calling oe_terminate_enclave()...\\n\");"
            << "            result = oe_terminate_enclave(enclave);"
            << "      }"
            << "      else {"
            << "            assert(enclave != NULL);"
            << "            assert(!strcmp(func,\"__aux_pop_oe_call_enclave_function\"));"
            << "            pos    = get_pos(bin_aux);"
            << "            if (pos != 0 && not_first) pos = 0;"
            << "            fprintf(stderr,\"Calling pop_calls function at pos %d\\n\",pos);"
            << "            result = (*pop_calls[pos])(pos);"
            << "            not_first = 0;"
            << "            fprintf(stderr,\"Done\\n\");"
            << "            if (verbose_pop_sgx)"
            << "                fprintf(stderr, \"Enclave function called (result %d)\\n\",result);"
            << "      }"
            << "      fclose(bin_aux);"
            << "      free(func);"
            << " "
            << "      if (!(bin_aux = fopen(\"aux_server_popsgx\",\"w+\"))){"
            << "             fprintf(stderr,\"untrusted bin at server failed to open file\");"
            << "             abort();"
            << "      }"
            << ""
            << "      fprintf(bin_aux,\"OK\\n%d\\n\",result);"
            << "      fclose(bin_aux);"
            << "}"
            << ""
            << create_prototype(edl_->name_) + "{"
            << ""
            << "    int ret; FILE *aux;"
            << "    char *name= \""+edl_->name_+"host\";"
            << "    char func[100]; "
            << ""
            << "     if ((ret = init_popsgx(name)) != 1) {"
            << "          puts(\"Could not initialize PopSGX\");"
            << "          abort(); "
            << "     }"
            << ""
            << "    /* On the server side, we only busy wait to handle calls. */"   
            <<"     if ((aux = fopen(\"aux_server_popsgx\",\"r\"))) {"
            << "        busy_wait_server(aux);"
            << "    }"
            << ""
            << "     sprintf(func,\"%s\",__func__);"
            << "" 
            << "     return popsgx_call(func,6,path,type,flags,settings,setting_count,enclave);" 
            << "}"
            << ""
            << "OE_EXTERNC_END";
      file_.close();
    }

    void trusted_function_ids()
    {
        out() << "enum"
              << "{";
        int idx = 0, i = 0;
        std::string pfx = "    " + edl_->name_ + "_fcn_id_";
        for (Function* f : edl_->trusted_funcs_){
            out() << pfx + f->name_ + " = " + to_str(idx++) + ",";
            if ((pfx + f->name_).find("_oe_") == std::string::npos){
                i = i + 1;
            }
        }
        out() << pfx + "trusted_call_id_max = OE_ENUM_MAX"
              << "};"
              << "" 
              << "#define MAX_POP_CALL_CUSTOM (" + std::to_string(i) + ")\n";
    }

    void trusted_function_names()
    {
        out() << "static const oe_ecall_info_t _" + edl_->name_ +
                     "_ecall_info_table[] = "
              << "{";
        for (Function* f : edl_->trusted_funcs_)
            out() << "    { \"" + f->name_ + "\" },";
        out() << "};"
              << "";
    }

    void trusted_function_arguments()
    {
        out() << "static const char* _" + edl_->name_ +
                     "_ecall_args_table[] = "
              << "{";
        for (Function* f : edl_->trusted_funcs_)
            out() << "    \"" + f->name_ + "_args_t\",";
        out() << "};"
              << "";
    }

    void pop_trusted_function()
    {   
        int i = 0, s = 0;

        for (Function* f : edl_->trusted_funcs_){
            pop_ecalls(f);
            i = i + 1;
        }

        out() << "\n /* Important PopSGX array: Used on server to call requested enclave work */"
              << "static oe_result_t (*pop_calls[" + std::to_string(i) + "])(int) ="
              << "{";

        for (Function* f : edl_->trusted_funcs_){

            if (s + 1 < i){
                out() << "  do_oe_call_enclave_" + f->name_ + ",";
            }
            else {
                out() << "  do_oe_call_enclave_" + f->name_;
            }
            s = s + 1;
        } 

        out() << "};\n";
    }

    void untrusted_function_ids()
    {
        int i = 0;
        out() << "enum"
              << "{";
        int idx = 0;
        std::string pfx = "    " + edl_->name_ + "_fcn_id_";
        for (Function* f : edl_->untrusted_funcs_){
            out() << pfx + f->name_ + " = " + to_str(idx++) + ",";
            if ((pfx + f->name_).find("_oe_") == std::string::npos){
                i = i + 1;
            }
        }
        out() << pfx + "untrusted_call_max = OE_ENUM_MAX"
              << "};"
              << ""
              << "#define MAX_POP_CALL_CUSTOM (" + std::to_string(i) + ")\n";
    }

    void ecall_marshalling_structs()
    {
        for (Function* f : edl_->trusted_funcs_)
            marshalling_struct(f, false);
    }

    void ocall_marshalling_structs()
    {
        for (Function* f : edl_->untrusted_funcs_)
            marshalling_struct(f, true);
    }

    void marshalling_struct(Function* f, bool ocall = false)
    {
        bool has_deep_copy_out_param = has_deep_copy_out(edl_, f);
        (void)ocall;
        out() << "typedef struct _" + f->name_ + "_args_t"
              << "{"
              << "    oe_result_t oe_result;"
              << "    uint8_t* deepcopy_out_buffer;"
              << "    size_t deepcopy_out_buffer_size;";
        indent_ = "    ";
        if (f->rtype_->tag_ != Void)
            out() << atype_str(f->rtype_) + " oe_retval;";
        for (Decl* p : f->params_)
        {
            out() << mdecl_str(p->name_, p->type_, p->dims_, p->attrs_) + ";";
            if (p->attrs_ && (p->attrs_->string_ || p->attrs_->wstring_))
                out() << "size_t " + p->name_ + "_len;";
        }
        if (f->errno_)
            out() << "int ocall_errno;";
        indent_ = "";
        out() << "} " + f->name_ + "_args_t;"
              << "";
    }

    void ecalls_table()
    {
        out() << "oe_ecall_func_t oe_ecalls_table[] = {";
        size_t idx = 0;
        for (Function* f : edl_->trusted_funcs_)
            out() << "    (oe_ecall_func_t) ecall_" + f->name_ +
                         (++idx < edl_->trusted_funcs_.size() ? "," : "");
        out() << "};"
              << ""
              << "size_t oe_ecalls_table_size = "
                 "OE_COUNTOF(oe_ecalls_table);"
              << "";
    }

    void ocalls_table()
    {
        out() << "static oe_ocall_func_t _" + edl_->name_ +
                     "_ocall_function_table[] = {";
        for (Function* f : edl_->untrusted_funcs_)
            out() << "    (oe_ocall_func_t) ocall_" + f->name_ + ",";
        out() << "    NULL"
              << "};"
              << "";
    }

    void emit_forwarder(Function* f)
    {
        FEmitter(edl_, file_).emit(f, gen_t_c_);
    }

    void prepare_is_pop_call(void)
    {
        out() << "int is_pop_call(int fnc_id, int ecall)"
              << "{"
              << "     int ret = 1;"
              /* For now, let's execute inner host calls inside the enclave in the server side 
               * (future work redirect back to client)
               */
              << "     if (!ecall) return 0;"
              /* Is it one of the appropiate o/ecalls? */
              << "      if (fnc_id < 0 || fnc_id >= MAX_POP_CALL_CUSTOM){"
              << "            ret = 0;"
              << "            if (ecall) assert(\"Extra ecalls should be redirected too\" && 0);"
              << "      }"
              << ""
              << "      return ret;"
              << "}\n";
    }

    void pop_emit_wrapper(Function* f, const std::string& prefix = "")
    {
        WEmitter(edl_, file_).pop_emit(f, !gen_t_c_, prefix);
    }

    void emit_wrapper(Function* f, const std::string& prefix = "")
    {
        WEmitter(edl_, file_).emit(f, !gen_t_c_, prefix);
    }
};

#endif // C_EMITTER_H
